I"u3<p>Without good key management, no cryptographic system is secure. Full knowledge of the Who, What, When, Where, Why and How of your keys is imperative for good security. Using an SSH Certificate Authority (CA) will vastly simplify and improve the efficacy of SSH infrastructure. You will no longer have default usernames and passwords (root:toor). You will no longer have to copy everyone’s public key into every server while trying to remember whose key is whos. You will no longer be tempted to create “One key to rule them ALL” and give that key to everyone who needs it. Your key management process will be reduced to installing a CA’s public key to each system and signing users public keys.</p>

<!--excerpt-->

<p><br /></p>

<h4 id="ssh-certificate-authorities">SSH Certificate Authorities</h4>

<p>An SSH CA is simply a special set of public/private key pairs that are used to cryptographically sign user or hosts public keys creating certificates that can be used to authenticate users to hosts, or hosts to users. This mutual authentication scheme can be enforced on both user and hosts systems to provide a greater level of assurance, “to both parties” that they are talking to who they think they are talking to.</p>

<p><br /></p>

<h4 id="ssh-certificates">SSH Certificates</h4>

<p>Certificates: user and host. consist of a public key, some identity information, one or more principal (user or host) names and a set of options that are then signed by a Certification Authority (CA) key. These signing options allow for a finer degree of control when granting access. Some of the options are:</p>

<ol>
  <li>Certificates can have start and end times, meaning that you can issue in advance and automatically expire when required.</li>
  <li>Source IP address restrictions, restricting the source address or CIDR allows for access segmentation within larger address ranges.</li>
  <li>Force command, forcing the execution of command instead of initiating an interactive shell (scripting, automation tasks).</li>
  <li>Permit or deny port/agent forwarding, permitting/preventing lateral movement within the network.</li>
</ol>

<p><br /></p>

<h4 id="ssh-key-revocation">SSH Key Revocation</h4>

<p>Any key management process must have a key revocation mechanism. SSH uses Key Revocation Lists (KRLs) on each server. While the management of this list is a manual process it is effective at forbidding to use or revoked keys and logging every attempt.</p>

<p><br /></p>

<h4 id="zero-trust">Zero Trust</h4>

<p>While SSH CA’s do not meet all the tenets of a Zero Trust - Access to Resources policy needs, they do meet the core requirements:</p>

<ul>
  <li>Provision for mutual user and hosts authentication</li>
  <li>Access expiry and revocation</li>
  <li>Application functionality restrictions</li>
  <li>Network location restrictions</li>
  <li>Logging; enough information to build behavioural and environmental attributes for each user.</li>
  <li>Auditable; the configuration is auditable.</li>
</ul>

<p><br /></p>

<h3 id="setup">SETUP</h3>

<p>To test all of this theory I am going to build and configure four Ubuntu docker containers; three clients alice@heavymessing, bob@justtesting and chloe@tacticalgrace and one server user@lastingdamage. I will create an SSH Certificate Authority, distributes the keys and configure all of the clients and the server, to ONLY trust CA-signed certificates.</p>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/a-setup.png" /> 
</p>

<p><br /></p>

<h4 id="root-vs-user">Root Vs. User</h4>

<p>I am using a common user account on the server called “user”, which implies that all users know the user’s password to enable them to gain sudo privileges.  However, you could just as easily use the root account, immediately granting root privileges and bypass the need for any password sharing. The choice is yours.</p>

<p><br /></p>

<p>Create user keys (for each user@host)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -f /home/user/.ssh/id_rsa 
</code></pre></div></div>

<p>Create user &amp; host CA certificates (root@lastingdamage)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir /root/ca_keys
$ ssh-keygen -f /root/ca_keys/ca_user_key
$ ssh-keygen -f /root/ca_keys/ca_host_key
</code></pre></div></div>

<p>Signing user’s public keys (root@lastingdamage, for each user@host)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -s /root/ca_keys/ca_user_key -I user@host -V +30m \
  -O source-address=172.18.0.0/24 \
  -n user /root/public_keys/user-host.pub
</code></pre></div></div>

<p>Creates a /root/public_keys/user@host-cert.pub file i.e. a “CA signed” users public key that is valid for 30 minutes and its usage is restricted to 172.18.0.0/24 subnet.</p>

<p>NOTE: The -V validity interval option “IS” server timezone sensitive!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ PUBLIC=$(ssh-keygen -L -f /root/public_keys/user@host-cert.pub \
  |grep "Public" |sed -e 's/:/ /g' |sed 's/^[ \t]*//' |sed 's/  / /g' \
  |cut -d" " -f1,5).
</code></pre></div></div>

<p>grepping the public keys SHA256 hash</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ SIGNING=$(ssh-keygen -L -f /root/public_keys/user@host-cert.pub \
  |grep "Signing" |sed -e 's/:/ /g' |sed 's/^[ \t]*//' |sed 's/  / /g' \
  |sed -e 's/\(using rsa-sha2-512\)//g' |cut -d" " -f1,5)
</code></pre></div></div>

<p>grepping the signing keys SHA256 hash</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "user@host $PUBLIC $SIGNING" &gt;&gt; /root/public_keys/public_key_index.txt 
</code></pre></div></div>

<p>The public_key_index.txt file contains a list of all the sign public keys.</p>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/07-public_key_index.png" /> 
</p>

<p>Server (root@lastingdamage)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -s /root/ca_keys/ca_host_key -I lastingdamage -h \
  -n lastingdamage -V +1d /etc/ssh/ssh_host_rsa_key.pub 
</code></pre></div></div>

<p>Sign servers public key creating /etc/ssh/ssh_host_rsa_key-cert.pub key that is valid for one day.</p>

<p>NOTE: The -V validity interval option “IS” server timezone sensitive!</p>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/d-cert.pub_ca.png" /> 
</p>

<p>Copy CA’s public key</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cp -fv /root/ca_keys/ca_user_key.pub /etc/ssh/
</code></pre></div></div>

<p>configure server /etc/ssh/sshd_config:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
LogLevel VERBOSE
TrustedUserCAKeys /etc/ssh/ca_user_key.pub
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
RevokedKeys /etc/ssh/revoked_keys
</code></pre></div></div>

<p>LogLevel VERBOSE must be used because LogLevel INFO does not log the certificate ID’s or key SHA256 hashes for login attempts that are made with expired certificates.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch /etc/ssh/revoked_keys &amp;&amp; chmod 644 /etc/ssh/revoked_keys 
</code></pre></div></div>

<p>The revoked_keys file MUST exist and be readable (even if empty) otherwise the server will not accept ANY connections.</p>

<p>Copy signed certificates to ~/.ssh &amp; update known_hosts (for each user@host)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cp -fv /root/public_keys/user@host-cert.pub /home/user/.ssh/id_rsa-cert.pub
$ printf "@cert-authority * " | cat - /root/ca_keys/ca_host_key.pub \
  &gt; /home/user/.ssh/known_hosts 
</code></pre></div></div>

<p>The user’s known hosts file now contains the CA’s host’s public key, meaning that the ssh client will allow connections to any server presenting this public key.</p>

<p><br /></p>

<h3 id="tests">TESTS</h3>

<p>To gain a level of assurance that the required functionality has been achieved, conducted the following tests.</p>

<p><br />1. User Identity</p>

<div style="padding-left: 15px;">
Alice &amp; Bob can login to user@lastingdamage without having someone copy their public keys to .ssh/authorized_keys first (ssh-copy-id) because they are using their signed public keys [name]-cert.pub. 
</div>

<p><br />2. Server Identity</p>

<div style="padding-left: 15px;">
Alice &amp; Bob do NOT get prompted with an "unknown host" warning message because the ca_host_key.pub is in their .ssh/known_hosts file
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/02-alice_login.png" /> 
    <img width="49%" src="/assets/images/02-bob_login.png" /> 
</p>

<p>3. Identity - logging</p>

<div style="padding-left: 15px;">
user@lastingdamage /var/log/auth.log should log individual certificate ID's.. tail -f /var/log/auth.log
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/03-alice_login_log.png" /> 
    <img width="49%" src="/assets/images/03-bob_login_log.png" /> 
</p>

<p><br />4. Identity - revocation</p>

<div style="padding-left: 15px;">
Server (root@lastingdamage)
</div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -kf /root/ca_keys/revoked_keys -z $COUNTER bob-justtesting.pub 
$ cp -fv /root/ca_keys/revoked_keys /etc/ssh/
$ chmod 644 /etc/ssh/revoked_keys
</code></pre></div></div>

<div style="padding-left: 15px;">
Bob should NOT be able to login to user@lastingdamage after his certificate is revoked.
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/04-bob_revoked_login.png" /> 
    <img width="49%" src="/assets/images/04-bob_revoked_log.png" /> 
</p>

<p><br />5. Identity - expire</p>

<div style="padding-left: 15px;">
Alice should NOT be able to login to user@lastingdamage after her certificate expires. 
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/05-alice_expire_login.png" /> 
    <img width="49%" src="/assets/images/05-alice_expire_log.png" /> 
</p>

<p>NOTE: The Valid: from to values “ARE” server timezone sensitive!</p>

<p><br />6. Network location</p>

<div style="padding-left: 15px;">
Chloe can't ssh to user@lastingdamage from outside 172.18.0.0/24 CIDR, even with valid keys.
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/06-chloe_location_login.png" /> 
    <img width="49%" src="/assets/images/06-chloe_location_log.png" /> 
</p>

<p><br />7. Identity - registry</p>

<div style="padding-left: 15px;">
A public_keys/public_key_index.txt file is created with an index of ID's and their PUBLIC keys which have been signed -&gt; used for identifying users when greping auth.log
</div>

<p align="center" width="100%">
    <img width="49%" src="/assets/images/07-public_key_index.png" /> 
</p>

<p><br /></p>

<h3 id="conclusion">Conclusion</h3>

<p>SSH key management is very simple:</p>
<ul>
  <li>All servers are configured to use CA keys and certificates</li>
  <li>The user provides their public key, CA signs the key and returns the resulting user certificate and the CA’s public key.</li>
  <li>The user configures their system and use the CA’s signed certificate.</li>
  <li>The user keys either expire or are revoked as required.</li>
  <li>SSH auth.log records all connection activity.</li>
</ul>

<p>You are making “One key to rule them ALL”  but it is a Certificate Authority key that never needs to be on an online system, it could/should reside on a USB key and only plugged in when needed.</p>

<p><br /></p>

<h3 id="references">References:</h3>

<p>MAN pages</p>

<ul>
  <li><a href="/assets/text/man_ssh-copy-id.txt">man ssh-copy-id</a></li>
  <li><a href="/assets/text/man_ssh-keygen.txt">man ssh-keygen</a></li>
  <li><a href="/assets/text/man_ssh.txt">man ssh</a></li>
  <li><a href="/assets/text/man_sshd.txt">man sshd</a></li>
</ul>

<p>NIST Special Publication 800-57 Recommendation for Key Management - Part 1: General (Revision 3)
<br />Elaine Barker, William Barker, William Burr, William Polk, and Miles Smid 
<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-57p1r3.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-57p1r3.pdf</a></p>

<p>NIST Special Publication 800-207 - Zero Trust Architecture 
<br />Scott Rose Oliver Borchert Stu Mitchell Sean Connelly 
<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf</a></p>

:ET